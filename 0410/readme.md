# React Hooks 가이드

## Hook이란?

**Hook**은 React 16.8에서 도입된 기능으로, 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 특별한 함수입니다. 클래스 컴포넌트 없이도 React의 모든 기능을 활용할 수 있게 해줍니다.

### Hook의 특징
- **함수형 컴포넌트 전용**: 클래스 컴포넌트에서는 사용 불가
- **재사용 가능**: 커스텀 Hook을 만들어 로직 공유 가능
- **선언적**: 명확하고 간결한 코드 작성
- **조합 가능**: 여러 Hook을 조합하여 복잡한 로직 구현

### Hook 사용 규칙
- **최상위에서만 호출**: 반복문, 조건문, 중첩 함수 내부에서 호출 금지
- **React 함수에서만 호출**: 일반 JavaScript 함수에서 호출 금지
- **순서 유지**: Hook 호출 순서는 항상 동일해야 함

## 기본 Hook

### useState
함수형 컴포넌트에서 상태를 관리하는 가장 기본적인 Hook입니다. 상태 값과 그 값을 업데이트하는 함수를 반환합니다.

**주요 특징:**
- 초기값 설정 가능
- 함수형 업데이트 지원
- 여러 상태를 독립적으로 관리

### useEffect
컴포넌트의 생명주기와 관련된 작업을 처리하는 Hook입니다. 컴포넌트가 렌더링된 후 실행되며, 정리(cleanup) 함수를 통해 메모리 누수를 방지할 수 있습니다.

**주요 기능:**
- 데이터 가져오기
- 구독(subscription) 설정
- DOM 직접 조작
- 타이머 설정

**의존성 배열:**
- 빈 배열: 컴포넌트 마운트 시에만 실행
- 특정 값들: 해당 값들이 변경될 때만 실행
- 생략: 매 렌더링마다 실행

### useContext
React Context API를 함수형 컴포넌트에서 쉽게 사용할 수 있게 해주는 Hook입니다. Provider에서 제공하는 값을 직접 구독할 수 있습니다.

**장점:**
- Props drilling 문제 해결
- 전역 상태 관리 가능
- 깔끔한 코드 작성

## 추가 Hook

### useReducer
복잡한 상태 로직을 관리할 때 useState 대신 사용하는 Hook입니다. Redux의 리듀서 패턴을 컴포넌트 레벨에서 사용할 수 있습니다.

**사용 시기:**
- 다양한 상태 변화가 있는 경우
- 상태 업데이트 로직이 복잡한 경우
- 하위 컴포넌트에서 콜백을 통해 상태를 업데이트하는 경우

### useMemo
계산 비용이 큰 값을 메모이제이션하여 성능을 최적화하는 Hook입니다. 의존성 배열의 값이 변경되지 않으면 이전에 계산된 값을 재사용합니다.

**사용 시기:**
- 복잡한 계산 결과를 캐싱할 때
- 참조 동일성이 중요한 객체나 배열을 생성할 때

### useCallback
함수를 메모이제이션하는 Hook입니다. 의존성 배열의 값이 변경되지 않으면 동일한 함수 인스턴스를 반환합니다.

**사용 시기:**
- 자식 컴포넌트에 콜백을 전달할 때
- useEffect의 의존성으로 함수를 사용할 때

### useRef
변경 가능한 참조 객체를 생성하는 Hook입니다. DOM 요소에 직접 접근하거나 값을 저장하는 용도로 사용됩니다.

**주요 용도:**
- DOM 요소 참조
- 컴포넌트 인스턴스 변수 저장
- 이전 값 저장

### useLayoutEffect
useEffect와 유사하지만 모든 DOM 변경 후 동기적으로 실행되는 Hook입니다. 브라우저가 화면을 그리기 전에 실행됩니다.

**사용 시기:**
- DOM 측정이 필요한 경우
- 깜빡임 방지가 필요한 경우

### useImperativeHandle
forwardRef와 함께 사용하여 부모 컴포넌트에 노출할 인스턴스 값을 커스터마이징하는 Hook입니다.

## 커스텀 Hook

### 커스텀 Hook이란?
사용자가 직접 만드는 Hook으로, 컴포넌트 로직을 함수로 뽑아내어 재사용할 수 있게 해줍니다. 이름은 "use"로 시작해야 합니다.

### 커스텀 Hook의 장점
- **로직 재사용**: 같은 로직을 여러 컴포넌트에서 사용
- **관심사 분리**: 컴포넌트와 비즈니스 로직 분리
- **테스트 용이성**: 로직을 독립적으로 테스트 가능
- **코드 정리**: 컴포넌트 코드가 더 깔끔해짐

### 일반적인 커스텀 Hook 예시
- **useFetch**: API 호출 로직
- **useLocalStorage**: 로컬 스토리지 관리
- **useDebounce**: 디바운스 처리
- **useToggle**: boolean 상태 토글

## Hook 사용 시 주의사항

### 의존성 배열 관리
useEffect, useMemo, useCallback 등에서 의존성 배열을 정확히 명시해야 합니다. 누락된 의존성은 버그의 원인이 될 수 있습니다.

### 무한 루프 방지
잘못된 의존성 설정이나 객체/배열의 새로운 생성은 무한 루프를 발생시킬 수 있습니다.

### 성능 최적화
useMemo와 useCallback은 성능 최적화 도구이지만, 남용하면 오히려 성능이 저하될 수 있습니다. 필요한 경우에만 사용해야 합니다.

### Hook 순서 유지
조건문이나 반복문 안에서 Hook을 호출하면 Hook의 순서가 바뀌어 오류가 발생할 수 있습니다.

## Hook의 장점

### 코드 재사용성
로직을 Hook으로 분리하면 여러 컴포넌트에서 쉽게 재사용할 수 있습니다.

### 함수형 프로그래밍
클래스 컴포넌트보다 함수형 패러다임에 더 적합하며, 함수의 조합으로 복잡한 로직을 구성할 수 있습니다.

### 번들 크기 최적화
사용하지 않는 생명주기 메서드나 기능들을 포함하지 않아 번들 크기를 줄일 수 있습니다.

### 테스트 용이성
순수 함수 형태로 작성된 Hook은 테스트하기 쉽습니다.

## Hook vs 클래스 컴포넌트

| 구분 | Hook (함수형) | 클래스 컴포넌트 |
|------|---------------|----------------|
| 상태 관리 | useState, useReducer | this.state, setState |
| 생명주기 | useEffect | componentDidMount 등 |
| 성능 최적화 | useMemo, useCallback | shouldComponentUpdate |
| 코드 길이 | 짧고 간결 | 상대적으로 길음 |
| 러닝 커브 | 낮음 | 높음 (this 바인딩 등) |
| 재사용성 | 높음 (커스텀 Hook) | 낮음 (HOC, render props) |

## 미래와 발전 방향

### Concurrent Features
React 18에서 도입된 동시성 기능들과 함께 사용할 수 있는 새로운 Hook들이 추가되고 있습니다.

### Server Components
서버 컴포넌트와 함께 사용할 수 있는 Hook들의 발전이 계속되고 있습니다.

### 성능 최적화
더 나은 성능 최적화를 위한 새로운 Hook들과 패턴들이 지속적으로 개발되고 있습니다.

## 주요 포인트

> **Hook**: 함수형 컴포넌트에서 상태와 생명주기 기능을 사용할 수 있게 해주는 함수

> **사용 규칙**: 최상위에서만 호출, React 함수에서만 사용, 순서 유지

> **기본 Hook**: useState, useEffect, useContext가 가장 기본적이고 중요

> **커스텀 Hook**: 로직을 재사용 가능한 함수로 분리하여 코드 품질 향상

> **성능 최적화**: useMemo, useCallback 등을 적절히 사용하여 불필요한 렌더링 방지
