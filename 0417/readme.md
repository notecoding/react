# React 주요 Hooks 심화 가이드

## useEffect

**useEffect**는 함수형 컴포넌트에서 부수 효과(side effects)를 처리하는 Hook입니다. 컴포넌트의 생명주기와 관련된 모든 작업을 담당합니다.

### useEffect의 동작 방식
컴포넌트가 렌더링된 후에 실행되며, DOM이 업데이트된 후 비동기적으로 호출됩니다. 클래스 컴포넌트의 componentDidMount, componentDidUpdate, componentWillUnmount를 하나로 통합한 개념입니다.

### 의존성 배열 패턴

#### 빈 배열 []
컴포넌트가 마운트될 때 한 번만 실행되고, 언마운트될 때 정리 함수가 실행됩니다. 초기 데이터 로딩이나 이벤트 리스너 등록에 주로 사용됩니다.

#### 의존성 값 지정 [dep1, dep2]
지정된 값들이 변경될 때만 Effect가 재실행됩니다. 특정 상태나 props의 변화에 반응해야 하는 경우에 사용합니다.

#### 의존성 배열 생략
매 렌더링마다 Effect가 실행됩니다. 성능상 좋지 않으므로 특별한 경우가 아니면 사용을 피해야 합니다.

### 정리(Cleanup) 함수
useEffect에서 반환하는 함수는 정리 함수로, 컴포넌트가 언마운트되거나 Effect가 다시 실행되기 전에 호출됩니다. 메모리 누수를 방지하고 불필요한 작업을 정리하는 데 사용됩니다.

### 주요 사용 사례
- **API 호출**: 서버에서 데이터를 가져오는 작업
- **구독 관리**: WebSocket, 이벤트 리스너 등의 구독 설정/해제
- **타이머**: setTimeout, setInterval 설정 및 정리
- **DOM 조작**: 직접적인 DOM 접근이 필요한 경우

### 주의사항
Effect 내부에서 사용하는 모든 값들을 의존성 배열에 포함해야 합니다. ESLint 플러그인을 사용하면 누락된 의존성을 자동으로 감지할 수 있습니다.

## useMemo

**useMemo**는 계산 비용이 큰 값을 메모이제이션하여 성능을 최적화하는 Hook입니다. 의존성이 변경되지 않으면 이전에 계산된 값을 재사용합니다.

### 동작 원리
첫 번째 인자로 받는 함수를 실행하여 값을 계산하고, 두 번째 인자인 의존성 배열의 값들이 변경되지 않으면 이전 결과를 반환합니다. 의존성이 변경되면 함수를 다시 실행하여 새로운 값을 계산합니다.

### 사용해야 하는 경우
- **복잡한 계산**: 렌더링마다 수행하기에는 비용이 큰 계산
- **참조 동일성**: 자식 컴포넌트의 props로 전달되는 객체나 배열
- **필터링/정렬**: 큰 데이터셋의 필터링이나 정렬 작업

### 사용하지 말아야 하는 경우
- **간단한 계산**: 계산 비용이 작은 경우 오히려 성능 저하
- **모든 값**: 무분별한 사용은 메모리 사용량만 증가
- **의존성이 자주 변경**: 의존성이 매번 바뀌면 메모이제이션 효과 없음

### 최적화 팁
useMemo의 의존성 배열에는 실제로 사용되는 값만 포함시키고, 가능한 한 안정적인 값들을 의존성으로 사용해야 합니다.

## useCallback

**useCallback**은 함수를 메모이제이션하는 Hook입니다. 의존성이 변경되지 않으면 동일한 함수 인스턴스를 반환하여 불필요한 렌더링을 방지합니다.

### 동작 방식
함수 정의와 의존성 배열을 받아서, 의존성이 변경되지 않으면 이전에 생성된 함수를 반환합니다. 함수의 참조 동일성을 보장하여 자식 컴포넌트의 불필요한 리렌더링을 방지합니다.

### 필요한 상황
- **자식 컴포넌트 props**: 함수를 자식 컴포넌트에 전달할 때
- **useEffect 의존성**: Effect의 의존성 배열에 함수를 포함할 때
- **이벤트 핸들러**: 자주 재생성되는 이벤트 핸들러 함수

### React.memo와의 조합
React.memo로 감싸진 컴포넌트에 함수를 props로 전달할 때 useCallback을 사용하면 함수가 변경되지 않는 한 컴포넌트가 리렌더링되지 않습니다.

### 주의사항
useCallback도 useMemo처럼 남용하면 안 됩니다. 함수 생성 비용이 메모이제이션 비용보다 작을 수 있으므로, 실제 성능 개선이 있는지 확인해야 합니다.

### 클로저 문제
useCallback 내부에서 사용하는 상태값들은 의존성 배열에 포함되어야 합니다. 그렇지 않으면 stale closure 문제가 발생할 수 있습니다.

## useRef

**useRef**는 변경 가능한 참조 객체를 생성하는 Hook입니다. 렌더링과 관계없이 값을 저장하고 DOM 요소에 직접 접근할 수 있게 해줍니다.

### 주요 특징
- **변경 가능**: current 속성을 통해 값 변경 가능
- **렌더링 무관**: 값이 변경되어도 컴포넌트가 리렌더링되지 않음
- **지속성**: 컴포넌트의 전체 생명주기 동안 값 유지

### DOM 요소 참조
가장 일반적인 사용법으로, DOM 요소에 직접 접근하여 포커스 설정, 스크롤 위치 조정, 크기 측정 등을 수행할 수 있습니다.

### 값 저장소
렌더링과 무관한 값들을 저장하는 용도로 사용됩니다. 타이머 ID, 이전 값, 인스턴스 변수 등을 저장할 수 있습니다.

### forwardRef와의 조합
부모 컴포넌트에서 자식 컴포넌트의 DOM 요소에 접근해야 할 때 forwardRef와 함께 사용합니다.

### useState vs useRef

| 구분 | useState | useRef |
|------|----------|---------|
| 리렌더링 | 값 변경 시 발생 | 값 변경 시 발생하지 않음 |
| 용도 | UI에 영향을 주는 상태 | UI와 무관한 값 저장 |
| 접근 방식 | 직접 접근 | .current를 통한 접근 |

### 주의사항
useRef의 current 값 변경은 리렌더링을 트리거하지 않으므로, UI에 반영되어야 하는 데이터는 useState를 사용해야 합니다.

## Custom Hook

**Custom Hook**은 React Hook의 로직을 재사용 가능한 함수로 분리한 것입니다. 컴포넌트 간 상태 로직을 공유하고 코드의 재사용성을 높일 수 있습니다.

### Custom Hook의 규칙
- **이름 규칙**: 반드시 "use"로 시작해야 함
- **Hook 사용**: 내부에서 다른 Hook들을 사용할 수 있음
- **순수 함수**: 같은 입력에 대해 같은 출력을 반환해야 함

### 작성 원칙
- **단일 책임**: 하나의 명확한 목적을 가져야 함
- **재사용성**: 여러 컴포넌트에서 사용 가능해야 함
- **추상화**: 구현 세부사항을 숨기고 깔끔한 API 제공

### 일반적인 Custom Hook 패턴

#### 데이터 가져오기 (useFetch)
API 호출, 로딩 상태, 에러 처리를 하나의 Hook으로 추상화합니다. 로딩 상태와 에러 상태를 함께 관리하여 일관된 데이터 페칭 경험을 제공합니다.

#### 로컬 스토리지 (useLocalStorage)
브라우저의 로컬 스토리지와 React 상태를 동기화하는 Hook입니다. 데이터 타입 변환, 에러 처리, 초기값 설정 등을 처리합니다.

#### 토글 상태 (useToggle)
boolean 상태와 그 상태를 토글하는 함수를 제공하는 간단한 Hook입니다. 모달, 드롭다운, 체크박스 등에 활용됩니다.

#### 디바운스 (useDebounce)
입력값의 변경을 지연시켜 성능을 최적화하는 Hook입니다. 검색 기능이나 API 호출 빈도를 줄이는 데 사용됩니다.

### Custom Hook의 장점
- **관심사 분리**: 비즈니스 로직과 UI 로직 분리
- **테스트 용이성**: 로직을 독립적으로 테스트 가능
- **코드 재사용**: 같은 로직을 여러 컴포넌트에서 사용
- **유지보수성**: 로직 변경 시 한 곳에서만 수정

### Custom Hook 설계 팁
- **명확한 API**: 사용하기 쉬운 인터페이스 제공
- **의존성 최소화**: 외부 의존성을 최소한으로 유지
- **에러 처리**: 적절한 에러 처리 로직 포함
- **타입 지원**: TypeScript 사용 시 적절한 타입 정의

### 컴포지션 패턴
여러 Custom Hook을 조합하여 더 복잡한 로직을 만들 수 있습니다. 각 Hook이 단일 책임을 가지고 있으면 조합하기 쉽습니다.

## 성능 최적화 전략

### 의존성 최적화
Hook의 의존성 배열을 최적화하여 불필요한 재실행을 방지합니다. 가능한 한 안정적인 값들을 의존성으로 사용하고, 객체나 배열은 useMemo로 메모이제이션합니다.

### 조건부 Hook 실행
Hook의 규칙상 조건부로 호출할 수는 없지만, Hook 내부에서 조건부 로직을 사용하여 불필요한 작업을 피할 수 있습니다.

### 지연 초기화
useState나 useMemo에서 초기값 계산이 비용이 클 때 함수를 전달하여 지연 초기화를 사용할 수 있습니다.

## 주요 포인트

> **useEffect**: 부수 효과 처리, 의존성 배열로 실행 조건 제어

> **useMemo**: 비용이 큰 계산값 메모이제이션으로 성능 최적화

> **useCallback**: 함수 메모이제이션으로 자식 컴포넌트 리렌더링 방지

> **useRef**: DOM 접근 및 렌더링과 무관한 값 저장

> **Custom Hook**: 로직 재사용과 관심사 분리로 코드 품질 향상
